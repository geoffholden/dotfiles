" General Options {{{
set nocompatible
scriptencoding utf-8
set encoding=utf-8

filetype off
autocmd!
" }}}
" Plugins {{{
call plug#begin('~/.vim/plugged')
Plug 'kien/ctrlp.vim'
Plug 'Shougo/neocomplete.vim'
Plug 'tpope/vim-commentary'
Plug 'vim-scripts/OmniCppComplete'
Plug 'godlygeek/tabular'
Plug 'majutsushi/tagbar'
Plug 'SirVer/ultisnips' | Plug 'honza/vim-snippets'
Plug 'vim-airline/vim-airline' | Plug 'vim-airline/vim-airline-themes'
Plug 'tpope/vim-dispatch'
Plug 'tpope/vim-fugitive'
Plug 'airblade/vim-gitgutter'
Plug 'fatih/vim-go', { 'for': 'go' }
Plug 'moorereason/vim-markdownfmt', { 'for': 'markdown' }
Plug 'tpope/vim-unimpaired'
Plug 'benmills/vimux'
Plug 'ConradIrwin/vim-bracketed-paste'
Plug 'scrooloose/syntastic'
" Syntax Only
Plug 'aklt/plantuml-syntax'
Plug 'freitass/todo.txt-vim'
Plug 'vim-scripts/ditaa'
Plug 'tpope/vim-markdown', { 'for': 'markdown' }
Plug 'tpope/vim-git'
call plug#end()
" }}}
" Theme {{{
set t_Co=256
colorscheme molokai

syntax enable
" }}}
" Vim UI {{{
set noswapfile
set number
set nohlsearch
set incsearch
set ruler
set scrolloff=4
set cursorline
set statusline=%F%m%r%h%w\ %{fugitive#statusline()}\ [%l,%c]\ [%L,%p%%]
set laststatus=2
let mapleader = ","
set spelllang=en_ca
set nospell
set listchars=tab:▸\ ,eol:¬

highlight ColorColumn ctermbg=234 guibg=#293739
if exists('+colorcolumn')
    set colorcolumn=80
endif

nnoremap <silent> <Leader>b :TagbarToggle<CR>
nmap <leader>g :tag<space>
map <silent> <C-n> :NERDTreeToggle<CR>

nnoremap <silent> <Leader>c<Space> :Commentary<CR>
vnoremap <silent> <Leader>c<Space> :Commentary<CR>
" }}}
" Text Formatting {{{
filetype on
filetype plugin indent on
set autoindent
set tabstop=4
set softtabstop=4
set shiftwidth=4
set shiftround
set expandtab
" }}}
" StripWhitespace {{{
function! StripWhitespace ()
    exec ':%s/ \+$//gc'
endfunction
map ,w :call StripWhitespace ()<CR>
" }}}
" neocomplete {{{
"
" omnicompletion (^X,^O)
set ofu=syntaxcomplete#Complete

let g:acp_enableAtStartup = 0
" Use neocomplete.
let g:neocomplete#enable_at_startup = 1
" Use smartcase.
let g:neocomplete#enable_smart_case = 1
" Set minimum syntax keyword length.
let g:neocomplete#sources#syntax#min_keyword_length = 3
let g:neocomplete#lock_buffer_name_pattern = '\*ku\*'

" Define dictionary.
let g:neocomplete#sources#dictionary#dictionaries = {
    \ 'default' : '',
    \ 'vimshell' : $HOME.'/.vimshell_hist',
    \ 'scheme' : $HOME.'/.gosh_completions'
        \ }

" Define keyword.
if !exists('g:neocomplete#keyword_patterns')
    let g:neocomplete#keyword_patterns = {}
endif
let g:neocomplete#keyword_patterns['default'] = '\h\w*'

" Plugin key-mappings.
inoremap <expr><C-g>     neocomplete#undo_completion()
inoremap <expr><C-l>     neocomplete#complete_common_string()

" Recommended key-mappings.
" <CR>: close popup and save indent.
inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
function! s:my_cr_function()
  "return neocomplete#close_popup() . "\<CR>"
  " For no inserting <CR> key.
  return pumvisible() ? neocomplete#close_popup() : "\<CR>"
endfunction
" <TAB>: completion.
inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"
" <C-h>, <BS>: close popup and delete backword char.
inoremap <expr><C-h> neocomplete#smart_close_popup()."\<C-h>"
inoremap <expr><BS> neocomplete#smart_close_popup()."\<C-h>"
inoremap <expr><C-y>  neocomplete#close_popup()
inoremap <expr><C-e>  neocomplete#cancel_popup()

autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags

" Enable heavy omni completion.
if !exists('g:neocomplete#sources#omni#input_patterns')
    let g:neocomplete#sources#omni#input_patterns = {}
endif
" }}}
" UltiSnips {{{
let g:UltiSnipsExpandTrigger="<S-tab>"
let g:UltiSnipsJumpForwardTrigger="<c-b>"
let g:UltiSnipsJumpBackwardTrigger="<c-z>"
" }}}
" CtrlP {{{
let g:ctrlp_extensions = ['tag', 'buffertag', 'mixed']
" }}}
" Airline {{{
let g:airline_powerline_fonts = 1
if !exists('g:airline_symbols')
  let g:airline_symbols = {}
endif
let g:airline_symbols.space = "\ua0"

let g:airline#extensions#default#section_truncate_width = {
      \ 'b': 79,
      \ 'x': 60,
      \ 'y': 120,
      \ 'z': 45,
      \ }
" }}}
" MacVim {{{
if has('macunix')
    set guifont=Menlo\ for\ Powerline
endif
" }}}
" Folding {{{
set foldmethod=syntax
set foldnestmax=2
set nofoldenable
nnoremap [of :set foldenable<CR>
nnoremap ]of :set nofoldenable<CR>
nnoremap cof :set <C-R>=eval('&foldenable') ? 'nofoldenable' : 'foldenable'<CR><CR>
" }}}
" vimrc auto-reload {{{
if has("autocmd")
    autocmd BufWritePost .vimrc source $MYVIMRC
    autocmd BufWritePost vimrc source $MYVIMRC
    autocmd BufWritePost vimrc.symlink source $MYVIMRC
endif
" }}}
" Disable Arrow Keys {{{
inoremap <Up> <Nop>
noremap  <Up> <Nop>
inoremap <Down> <Nop>
noremap  <Down> <Nop>
inoremap <Left> <Nop>
noremap  <Left> <Nop>
inoremap <Right> <Nop>
noremap  <Right> <Nop>
" }}}
" Tmux {{{
" Transfer default register to/from tmux paste buffer
function! RegisterToTmux ()
    call system('tmux load-buffer -', getreg())
endfunction
function! TmuxToRegister ()
    call setreg(v:register, system('tmux save-buffer -'))
endfunction
map <silent> <Leader>tp :call RegisterToTmux()<CR>
map <silent> <Leader>tg :call TmuxToRegister()<CR>

let g:VimuxUseNearest = 0
" }}}
" Tabular mappings {{{
nmap <Leader>a& :Tabularize /&<CR>
vmap <Leader>a& :Tabularize /&<CR>
nmap <Leader>a= :Tabularize /=<CR>
vmap <Leader>a= :Tabularize /=<CR>
nmap <Leader>a=> :Tabularize /=><CR>
vmap <Leader>a=> :Tabularize /=><CR>
nmap <Leader>a: :Tabularize /:<CR>
vmap <Leader>a: :Tabularize /:<CR>
nmap <Leader>a:: :Tabularize /:\zs<CR>
vmap <Leader>a:: :Tabularize /:\zs<CR>
nmap <Leader>a, :Tabularize /,<CR>
vmap <Leader>a, :Tabularize /,<CR>
nmap <Leader>a,, :Tabularize /,\zs<CR>
vmap <Leader>a,, :Tabularize /,\zs<CR>
nmap <Leader>a<Bar> :Tabularize /<Bar><CR>
vmap <Leader>a<Bar> :Tabularize /<Bar><CR>
" }}}
" markdownfmt {{{
let g:markdownfmt_command = 'mdfmt'
let g:markdownfmt_autosave = 1
let g:markdown_fenced_languages = ['cpp', 'go', 'ditaa', 'dot', 'plantuml']
" }}}
" Large File Function {{{
" https://github.com/tejr/dotfiles/blob/4f9e40bc40242a8e110ad87908936c835ad1b804/vim/vimrc#L565-L579
" When opening a large file, take some measures to keep things loading quickly
if has('eval') && has('autocmd')

  " Threshold is 10 MB in size
  let g:bigfilesize = 10 * 1024 * 1024

  " Declare function for turning off slow options
  function! BigFileMeasures()
    let l:file = expand("<afile>")
    if getfsize(l:file) > g:bigfilesize
      setlocal nobackup
      setlocal nowritebackup
      setlocal noswapfile
      if has('persistent_undo')
        setlocal noundofile
      endif
      if exists('&synmaxcol')
        setlocal synmaxcol=256
      endif
    endif
  endfunction

  " Define autocmd for calling to check filesize
  augroup bigfilesize
    autocmd!
    autocmd BufReadPre * call BigFileMeasures()
  augroup end
endif
" }}}
" vim:foldmethod=marker:foldlevel=0:foldenable
